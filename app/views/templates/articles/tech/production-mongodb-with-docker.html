<h2>Introduction</h2>
<p>Docker has very quickly turned from a nascent technology to a ubiquitous
  deployment strategy for a wide variety of projects. However, Docker's use for
  running long-lasting and production grade database systems is still perceived
  with subjective hesitation. The primary reason for this mistrust is relatively
  lower database performance compared to native installations, which is expected
  due to introduction of an additional networking layer (Docker's intermediate
  network drivers) between database clients and the database server.</p>
<p>Another reason why system architects shy away from using Docker for database
  deployments is the general sense of unease around keeping their precious data
  with a less used/understood database setup.</p>
<p>In this article, we will try to address the second concern system architects
  have by setting up a production-grade MongoDB system using Docker.</p>

<h2>What does this Setup covers</h2>
<p>In this setup we will look at setting up a MongoDB setup which:</p>
<ul>
  <li>Can recover from failures.</li>
  <li>Can recover from unplanned system reboots.</li>
  <li>Doesn't overruns the system storage with log records.</li>
  <li>Has automated backup and restore strategies.</li>
</ul>

<h2>What this setup doesn't covers</h2>
<p>For the sake of brevity and avoiding bloat, this article considers the
  following features/strategies out of scope:</p>
<ul>
  <li>MongoDB replication and sharding.</li>
  <li>MongoDB authentication.</li>
</ul>

<h2>Setup</h2>

<h3>Running Docker container</h3>
<p>Data generated by Docker containers is lost when the container is
  stopped. Since we obviously would not want to lose our priceless data, we will
  work around this problem by using Docker's
  <a href="https://docs.docker.com/storage/bind-mounts/" target="_blank">bind
  mounts</a>. Bind mounts allow a file or directory on the host machine to be
  mounted into a container.</p>

<h4>Preparing directory structure on host.</h4>
<pre><code class="language-bash">mkdir -p /home/surender/data/mongo/db
mkdir -p /home/surender/data/mongo/backup</code></pre>
<p>As the directory names suggest,
  <span class="code">/home/surender/data/mongo/db</span> will be used to persist
  Mongo's DB files between container runs and
  <span class="code">/home/surender/data/mongo/db</span> will be used to store
  Mongo backups.</p>

<h4>Running a perennial MongoDB docker container.</h4>
<pre><code class="language-bash">docker run -d -p 27017:27017 \
--restart unless-stopped \
--log-driver json-file \
--log-opt max-size=10m \
--log-opt max-file=5 \
-e TZ=Asia/Kolkata \
-v /home/surender/data/mongo/db:/data/db \
-v /home/surender/data/mongo/backup:/data/backup \
--name mongo_container \
mongo:4.0.8 --timeStampFormat ctime</code></pre>
<p>We will use the above command to start a long-running container with Mongo
  inside. Let us have a look at all the options in the command:</p>
<ul>
  <li><strong>-d</strong> runs the container in daemon/detached
    mode. The container will run as a background task and will not block the
    current shell.</li>
  <li><strong>-p</strong> publishes a port from inside the container and binds
    it to a port on the host. Here we have kept both host and container ports
    identical (<span class="code">27017</span>) to avoid ambiguity and simulate
    a native MongoDB setup.</li>
  <li><strong>--restart unless-stopped</strong> sets the container's restart
    policy to always restart the container unless explicitly stopped. This
    policy is imperative for recovery from container crashes and system reboots.
  </li>
  <li><strong>--log-driver json-file</strong> configures the container to use
    the default logging driver <span class="code">json-file</span>. Container
    will output logs to a log file formatted as JSONs.</li>
  <li><strong>--log-opt max-size=10m</strong> configures the container's logging
    strategy to not create a log file larger than 10 megabytes. Large log files
    are difficult to be parsed in most text editors and are often unusable. If
    a log file's size exceeds the specified limit the log file is
    <em>rotated</em> i.e. a new log file is created for logging new entries
    while the existing log file is renamed and archived.</li>
  <li><strong>--log-opt max-file=5</strong> directs the docker daemon to not
    keep more than <span class="code">5</span> archived log files. When a new
    archived log file is created after log rotation the oldest archived log file
    is deleted. This keeps the system storage being run over with log files.
  </li>
  <li><strong>-e TZ=Asia/Kolkata</strong> sets the timezone environment variable
    <span class="code">TZ</span> inside the container to
    <span class="code">Asia/Kolkata</span>. The <span class="code">mongod</span>
    process inside the container will use this timezone while creating Mongo
    logs.</li>
  <li><strong>-v</strong> option like we discussed earlier, bind mounts a
    directory on the host with a directory inside the container. In our
    container MongoDB will use <span class="code">/data/db</span> directory to
    store database files and we will be using
    <span class="code">/data/backup</span> directory to dump our MongoDB
    backups.</li>
  <li><strong>--timeStampFormat ctime</strong> option unlike all other options
    is not a docker command's option, instead it is an option on the
    <span class="code">mongod</span> command-line service. It configures the
    MongoDB to use a more human-readable timestamp in the logs. This is an
    optional setting and we can choose to omit it.</li>
</ul>

<h3>Taking manual backup of all databases.</h3>
<pre><code class="language-bash">docker exec -it mongo_container mongodump --out /data/backup/manual</code></pre>

<h3>Manually restoring from the manual MongoDB dump.</h3>
<pre><code class="language-bash">docker exec -it mongo_container mongorestore /data/backup/manual --drop</code></pre>

<h3>Preparing log file to record backup cron job's events.</h3>
<pre><code class="language-bash">sudo mkdir -p /home/surender/data/mongo/logs
sudo touch /home/surender/data/mongo/logs/backup.log
sudo chmod 666 /home/surender/data/mongo/logs/backup.log</code></pre>

<h3>Shell script to backup MongoDB to a tarball file.</h3>
<pre><code class="language-bash">#!/bin/sh

set -e

HOST_BACKUPS_DIR=/home/surender/data/mongo/backup
DOCKER_BACKUPS_DIR=/data/backup

# Creates backup names like 2019-04-18
BACKUP_NAME=`date +%F`

HOST_BACKUP_DEST=$HOST_BACKUPS_DIR/$BACKUP_NAME
DOCKER_BACKUP_DEST=$DOCKER_BACKUPS_DIR/$BACKUP_NAME

BACKUP_TTL_DAYS=15

echo `date` Backing up in $DOCKER_BACKUP_DEST
docker exec mongo_container mongodump --out $DOCKER_BACKUP_DEST

echo `date` Compressing backup directory to $BACKUP_NAME.tar.gz
cd $HOST_BACKUPS_DIR
tar -zcvf $BACKUP_NAME.tar.gz $BACKUP_NAME

echo `date` Removing backup directory $HOST_BACKUP_DEST
rm -rf $HOST_BACKUP_DEST

echo `date` Deleting backup tarballs older than $BACKUP_TTL_DAYS days in $HOST_BACKUPS_DIR
find $HOST_BACKUPS_DIR -type f -mtime +$BACKUP_TTL_DAYS -exec rm '{}' +

echo `date` Mongo backup successful</code></pre>

<h3>Shell script to restore MongoDB from a tarball dump file.</h3>
<pre><code class="language-bash">#!/bin/sh

set -e

HOST_BACKUPS_DIR=/home/surender/data/mongo/backup
DOCKER_BACKUPS_DIR=/data/backup

BACKUP_NAME=$1

HOST_BACKUP_DEST=$HOST_BACKUPS_DIR/$BACKUP_NAME
DOCKER_BACKUP_DEST=$DOCKER_BACKUPS_DIR/$BACKUP_NAME

if [ -f $HOST_BACKUP_DEST.tar.gz ]
then
  echo `date` Uncompressing backup tarball $HOST_BACKUP_DEST.tar.gz
  cd $HOST_BACKUPS_DIR
  tar -zxvf $BACKUP_NAME.tar.gz

  echo `date` Restoring from $DOCKER_BACKUP_DEST
  docker exec -it mongo_container mongorestore $DOCKER_BACKUP_DEST --drop

  echo `date` Restore successful
else
  echo `date` Backup tarball $HOST_BACKUP_DEST.tar.gz not found!
fi</code></pre>

<h3>Crontab entry for scheduling nightly backups.</h3>
<pre><code class="language-bash">0 1 * * * /home/surender/mongo-backup.sh >> /home/surender/data/mongo/logs/backup.log 2>&1</code></pre>

<h3>Command to restore from a nightly backup tarball.</h3>
<pre><code class="language-bash">sudo ./home/surender/mongo-restore.sh &lt;yyyy-mm-dd&gt;</code></pre>
