<h2>Why should we Dockerize?</h2>
<p>Dockerizing an application is the process of configuring the application and
  its environment to package in a single
  <a href="https://www.docker.com/" target="_blank">Docker</a> image and to run
  it within Docker containers.</p>
<p>Even though <a href="https://golang.org/" target="_blank">Go (GoLang)</a>
  applications (mostly) compile to a single binary, applications often depend
  on other supporting files (templates, configurations, etc). When there are a
  lot of supporting files in an application, it is common to have problems
  because of out of sync codebase. Turning your Go application into a Docker
  image is a great way to distribute & deploy your application and be assured
  that it will run on other machines exactly like it did on development
  regardless of any customizations that machine might have.</p>

<h2>How to Dockerize?</h2>
<p>Here we will learn how to Dockerize a Go web application for development as
  well as production environments. While dockerizing web applications is a
  pretty straight-forward task, there are a few challenges unique to every
  language/technology that needs to be overcome.</p>
<p>Let's start by creating a simple web application which:</p>
<ul>
  <li>Listens for HTTP requests on a port. (let's say 18770)</li>
  <li>Handles a GET request <span class="code">/get</span> with a
    <span class="code">name</span> parameter.</li>
  <li>On receiving a request, responds back with a "Hello" message and a lucky
    number.</li>
</ul>
<p><em class="bold">Before we begin, it is imperative to have a working
  knowledge of Go (its build, test and run processes) and Docker.
  <a href="https://golang.org/doc/" target="_blank">https://golang.org/doc/</a>
  and <a href="https://docs.docker.com/" target="_blank">
    https://docs.docker.com/</a> can be good places to begin.</em></p>
<h3>Project Directory Structure</h3>
<p>Let us start by creating the requisite directory structure first. Let's name
  our project <span class="code">my_go_project</span> and have the following
  file and folder structure.</p>
<pre>
my_go_project/
    ├── src/
    │     └── my_go_project/
    │             ├── main.go
    │             └── main_test.go
    ├── docker-compose.yml
    ├── Dockerfile
    └── Makefile
</pre>
<h3>main.go</h3>
<p>In <span class="code">main.go</span>, lets write our simple web application
  as follows:</p>
<pre><code class="language-go">package main

import (
	"flag"
	"fmt"
	"log"
	"net/http"
)

func main() {
	http.HandleFunc("/get", func(w http.ResponseWriter, r *http.Request) {

		name := r.URL.Query()["name"][0]
		fmt.Fprintf(w, "Hello, %q\nYour lucky number is: %d", name, generateLuckyNumber(name))
	})

	err := http.ListenAndServe(":18770", nil) // Note: Not "localhost:18770" but ":18770"
	log.Fatal(err)
}

// Function to return a lucky number for a given name.
func generateLuckyNumber(name string) int {
	// Not really generating a lucky number here, just returning length of the string.
	return len(name)
}</code></pre>
<p>Here we are started a simple HTTP server which listens on port
  <span class="code">18770</span> for <span class="code">/get</span> GET
  request and expects parameter <span class="code">name</span>. We are
  generating a lucky number (not really :p) and returning a response text.</p>
<p>Note: In the above code, we are only making use of Go's internal packages.
  Soon we will be using an external package
  <a href="https://github.com/golang/glog" target="_blank">glog</a> to
  demonstrate how to manage external dependencies.</p>
<h3>main_test.go</h3>
<p>Even the most brilliant coders are incapable of writing codes that always
  work exactly as intended. Therefore testing is an important part of the
  software development process. Test-driven development helps in keeping the
  quality of your code high and protects from regressions.</p>
<p>Let's update our <span class="code">main_test.go</span> to contain our
  test cases as follows:</p>
  <pre><code class="language-go">package main

  import (
  	"testing"
  )

  // Unit test for generateLuckyNumber() using test tables.
  func TestGenerateLuckyNumber(t *testing.T) {
  	testCases := []struct {
  		name string
  		want int
  	}{
  		{
  			name: "surender",
  			want: 8,
  		},
  		{
  			name: "thakran",
  			want: 7,
  		},
  	}
  	for _, test := range testCases {
  		result := generateLuckyNumber(test.name)

  		if result != test.want {
  			t.Errorf("generateLuckyNumber(%s) -> %d want %d", test.name, result, test.want)
  		}
  	}
  }
</code></pre>
<p>This concludes our basic web application which we will be dockerizing
  next.</p>
<h3>Container Directory Structure</h3>
<p>Before we continue on to dockerizing out application we need to decide on
  the directory structure we intend inside a docker container.</p>
<p>The following directory structure should serve our purposes.</p>
<pre>
/workspace/
    ├── src/
    │     └── my_go_project/
    │             ├── main.go
    │             └── main_test.go
    ├── bin/
    │     ├── my_go_project
    ├── pkg/
    ├── docker-compose.yml
    ├── Dockerfile
    └── Makefile
</pre>
<h3>Dockerfile</h3>
<p>Every dockerized application must have a
  <a href="https://docs.docker.com/engine/reference/builder/" target="_blank">
    Dockerfile</a> which is usually located in the root of the application. A
  Dockerfile is a text document that contains all the commands a user could
  call on the command line to assemble an image.</p>
<p>Let's create a Dockerfile which has the following content:</p>
<pre><code class="language-docker">FROM surenderthakran/go:1.7.3

MAINTAINER https://github.com/surenderthakran

ENV GOPATH /workspace
ENV PATH "$PATH:$GOPATH/bin"

ADD ./ $GOPATH

WORKDIR $GOPATH

RUN make install

CMD make run
</code></pre>
<p>I usually prefer to use my own base images while dockerizing my applications
  so that I have more control over what goes into my projects (just because I
  can :p). We are free to use
  <a href="https://hub.docker.com/r/surenderthakran/go/" target="_blank">
    surenderthakran/go:1.7.3</a> or choose an
  <a href="https://hub.docker.com/_/golang/" target="_blank">
    Official Docker Image</a>.</p>
<h2>The Final Solution</h2>
<p>Let's have a look at
  <a href="https://github.com/surenderthakran/go_docker_env" target="_blank">
  surenderthakran/go_docker_env</a> which (IMHO) is a complete Go Docker
  Environment solution from which all team and project sizes can benefit.</p>
