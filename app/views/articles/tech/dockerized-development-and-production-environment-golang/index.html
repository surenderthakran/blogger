<h2>Why should we Dockerize?</h2>
<p>Dockerizing an application is the process of configuring the application and
  its environment to package in a single
  <a href="https://www.docker.com/" target="_blank">Docker</a> image and to run
  it within Docker containers.</p>
<p>Even though <a href="https://golang.org/" target="_blank">Go (GoLang)</a>
  applications (mostly) compile to a single binary, applications often depend
  on other supporting files (templates, configurations, etc). When there are a
  lot of supporting files in an application, it is common to have problems
  because of out of sync codebase. Turning your Go application into a Docker
  image is a great way to distribute & deploy your application and be assured
  that it will run on other machines exactly like it did on development
  regardless of any customizations that machine might have.</p>

<h2>How to Dockerize?</h2>
<p>Here we will learn how to Dockerize a Go web application for development as
  well as production environments. While dockerizing web applications is a
  pretty straight-forward task, there are a few challenges unique to every
  language/technology that needs to be overcome.</p>
<p>Let's start by creating a simple web application which:</p>
<ul>
  <li>Listens for HTTP requests on a port. (let's say 18770)</li>
  <li>Handles a GET request <span class="code">/get</span> with a
    <span class="code">name</span> parameter.</li>
  <li>On receiving a request, responds back with a "Hello" message and a lucky
    number.</li>
</ul>
<p><em class="bold">Before we begin, it is imperative to have a working
  knowledge of Go (its build, test and run processes) and Docker.
  <a href="https://golang.org/doc/" target="_blank">https://golang.org/doc/</a>
  and <a href="https://docs.docker.com/" target="_blank">
    https://docs.docker.com/</a> can be good places to begin.</em></p>
<h3>Project Directory Structure</h3>
<p>Let us start by creating the requisite directory structure first. Let's name
  our project <span class="code">my_go_project</span> and have the following
  file and folder structure.</p>
<pre>
my_go_project/
    ├── src/
    │     └── my_go_project/
    │             ├── main.go
    │             └── main_test.go
    ├── docker-compose.yml
    ├── Dockerfile
    └── Makefile
</pre>
<h3>main.go</h3>
<p>In <span class="code">main.go</span>, lets write our simple web application
  as follows:</p>
<pre><code class="language-go">package main

import (
	"flag"
	"fmt"
	"log"
	"net/http"
)

func main() {
	http.HandleFunc("/get", func(w http.ResponseWriter, r *http.Request) {

		name := r.URL.Query()["name"][0]
		fmt.Fprintf(w, "Hello, %q\nYour lucky number is: %d", name, generateLuckyNumber(name))
	})

	err := http.ListenAndServe(":18770", nil) // Note: Not "localhost:18770" but ":18770"
	log.Fatal(err)
}

// Function to return a lucky number for a given name.
func generateLuckyNumber(name string) int {
	// Not really generating a lucky number here, just returning length of the string.
	return len(name)
}</code></pre>
<p>Here we are started a simple HTTP server which listens on port
  <span class="code">18770</span> for <span class="code">/get</span> GET
  request and expects parameter <span class="code">name</span>. We are
  generating a lucky number (not really :p) and returning a response text.</p>
<p>Note: In the above code, we are only making use of Go's internal packages.
  Soon we will be using an external package
  <a href="https://github.com/golang/glog" target="_blank">glog</a> to
  demonstrate how to manage external dependencies.</p>
<h3>main_test.go</h3>
<p>Even the most brilliant coders are incapable of writing codes that always
  work exactly as intended. Therefore testing is an important part of the
  software development process. Test-driven development helps in keeping the
  quality of your code high and protects from regressions.</p>
<p>Let's update our <span class="code">main_test.go</span> to contain our
  test cases as follows:</p>
  <pre><code class="language-go">package main

  import (
  	"testing"
  )

  // Unit test for generateLuckyNumber() using test tables.
  func TestGenerateLuckyNumber(t *testing.T) {
  	testCases := []struct {
  		name string
  		want int
  	}{
  		{
  			name: "surender",
  			want: 8,
  		},
  		{
  			name: "thakran",
  			want: 7,
  		},
  	}
  	for _, test := range testCases {
  		result := generateLuckyNumber(test.name)

  		if result != test.want {
  			t.Errorf("generateLuckyNumber(%s) -> %d want %d", test.name, result, test.want)
  		}
  	}
  }
</code></pre>
<p>This concludes our basic web application which we will be dockerizing
  next.</p>
<h3>Container Directory Structure</h3>
<p>Before we continue on to dockerizing our application we need to decide on
  the directory structure we intend <em>inside</em> a docker container.</p>
<p>The following directory structure should serve our purposes.</p>
<pre>
/workspace/
    ├── src/
    │     ├── my_go_project/
    │     │        ├── main.go
    │     │        └── main_test.go
    │    ...                            // External dependencies.
    ├── bin/
    │     ├── my_go_project             // Final project binary.
    │    ...                            // Other binaries (if any).
    ├── pkg/                            // Go package objects.
    ├── docker-compose.yml
    ├── Dockerfile
    └── Makefile
</pre>
<p>Note that we are placing our project in the filesystem root's
  <span class="code">/workspace</span> directory. It is a personal choice to
  use any directory you want because we usually load one project in a container.
</p>
<h3>Dockerfile</h3>
<p>Every dockerized application must have a
  <a href="https://docs.docker.com/engine/reference/builder/" target="_blank">
    Dockerfile</a> which is usually located in the root of the application. A
  Dockerfile is a text document that contains all the commands a user could
  call on the command line to assemble an image.</p>
<p>Let's create a Dockerfile which has the following content:</p>
<pre><code class="language-docker">FROM surenderthakran/go:1.7.3

MAINTAINER https://github.com/surenderthakran

ENV GOPATH /workspace
ENV PATH "$PATH:$GOPATH/bin"

ADD ./ $GOPATH

WORKDIR $GOPATH

RUN make install

CMD make run
</code></pre>
<p>I usually prefer to use my own base images while dockerizing my applications
  so that I have more control over what goes into my projects (just because I
  can :p). We are free to use
  <a href="https://hub.docker.com/r/surenderthakran/go/" target="_blank">
    surenderthakran/go:1.7.3</a> or choose an
  <a href="https://hub.docker.com/_/golang/" target="_blank">
    Official Docker Image</a>.</p>
<p>First we need to update a couple of environment variables:
  <span class="code">$GOPATH</span> and <span class="code">$PATH</span>. We set
  our <span class="code">$GOPATH</span> as <span class="code">/workspace</span>.
  This environment variable specifies the location of our workspace and this
  where Go will look for <span class="code">/src</span>,
  <span class="code">/bin</span> and <span class="code">/pkg</span> directories.
</p>
<p>Next we added our project's code base to our
  <span class="code">$GOPATH</span> directory inside the container and change
  the present working directory to it.</p>
<p>The <span class="code">RUN</span> and <span class="code">CMD</span>
  instructions in their simpler form are to build our image and to run our
  containers respectively. <span class="code">RUN</span> instruction is
  executed while building our docker image and <span class="code">CMD</span>
  instruction is executed at runtime when we launch the container.</p>
<h3>Makefile</h3>
<p>I (and a lot of other developers) prefer to keep the actual image building
  and run commands out of the Dockerfile for a number of reasons. I personally
  prefer to use <span class="code">make</span>.</p>
<p>Update our Makefile to have the following content:</p>
<pre><code class="language-makefile">GO_PROJECT_NAME := my_go_project

# Go rules
go_format:
	@echo "\n....Formatting $(GO_PROJECT_NAME)'s go files...."
	gofmt -w $(GOPATH)/src/$(GO_PROJECT_NAME)

go_prep_install:
	@echo "\n....Preparing installation environment for $(GO_PROJECT_NAME)...."
	mkdir -p $(GOPATH)/bin $(GOPATH)/pkg
	go get github.com/cespare/reflex

go_dep_install:
	@echo "\n....Installing dependencies for $(GO_PROJECT_NAME)...."
	go get ./...

go_install:
	@echo "\n....Compiling $(GO_PROJECT_NAME)...."
	go install $(GO_PROJECT_NAME)

go_test:
	@echo "\n....Running tests for $(GO_PROJECT_NAME)...."
	go test ./src/$(GO_PROJECT_NAME)/...

go_run:
	@echo "\n....Running $(GO_PROJECT_NAME)...."
	$(GOPATH)/bin/$(GO_PROJECT_NAME)


# Project rules
install:
	$(MAKE) go_prep_install
	$(MAKE) go_dep_install
	$(MAKE) go_install

run:
ifeq ($(CODE_ENV), dev)
	reflex -s -g 'src/$(GO_PROJECT_NAME)/*.go' make restart
else
	$(MAKE) go_run
endif

restart:
	@$(MAKE) go_format
	@$(MAKE) go_install
	@$(MAKE) go_test
	@$(MAKE) go_run

.PHONY: go_format go_prep_install go_dep_install go_install go_run install run restart
</code></pre>
<p>Most of what is written above should be easy to grasp for someone who has
  used Makefile's before. If you have not I strongly recommend to atleast
  skim over the
  <a href="https://www.gnu.org/software/make/manual/make.html" target="_blank">
    Official GNU Make manual</a>.</p>
<h2>The Final Solution</h2>
<p>Let's have a look at
  <a href="https://github.com/surenderthakran/go_docker_env" target="_blank">
  surenderthakran/go_docker_env</a> which (IMHO) is a complete Go Docker
  Environment solution from which all team and project sizes can benefit.</p>
